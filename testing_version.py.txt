#!/usr/bin/python

num_attempts_to_switch_link_in_fail_state = 5
num_attempts_to_switch_link_in_active_state = 3
icmp_interval = 3

routes = ["default", "192.168.1.0/24", "1.1.1.1/32"]

main_iface = "eth0" 
main_nexthop = "172.16.15.1"
main_source = "172.16.15.22" 
main_prio = 100 
main_track_ip = ['172.16.104.1', '172.16.103.1', '172.16.103.2']
main_enable = True
main_desc = "RTK"

back_iface = "eth1" 
back_nexthop = "172.16.16.1"
back_source = "172.16.16.22" 
back_prio = 50 
back_track_ip = ['172.16.104.1', '172.17.10.100']
back_enable = True
back_desc = "Okado"

import threading
import subprocess as sp
import time
import signal
import sys

link0 = {'iface': main_iface, 'nexthop': main_nexthop, 'source': main_source, 'prio': main_prio, 'track-host': main_track_ip, 'enable': main_enable, 'desc': main_desc}
link1 = {'iface': back_iface, 'nexthop': back_nexthop, 'source': back_source, 'prio': back_prio, 'track-host': back_track_ip, 'enable': back_enable, 'desc': back_desc}

current_iface = None
previous_iface = None
all_ifaces_are_in_fail_status = None

links = [link0, link1]
links_status = {}
threads = []

shutdown_event = threading.Event()
lock_for_links_status = threading.RLock()

with lock_for_links_status:
    for link in links:
        links_status.update({ link.get('iface'): { 'status': None, 'prio': link.get('prio') } })

# ip rule add from all iif lo oif eth0 lookup 100
# ip rule add from all iif lo oif eth1 lookup 101
# ip route add default via 172.16.15.1 table 100
# ip route add default via 172.16.16.1 table 101

def get_prio_of_iface (iface):
    with lock_for_links_status:
        for link in links:
            if iface == link.get('iface'):
                return link.get('prio')
    
    return None        

def get_link_by_iface (iface):
    with lock_for_links_status:
        for link in links:
            if iface == link.get('iface'):
                return link
    
    return None     
    
def ip_rule_mgr (action, out_iface, table_id):
    # if action == "add" - this function add ip rule for pass local traffic, 
    # which outgoing from iface (oif) to specific route table (table_id)
    # if if action == "del" - this function delete ip rule
    
    # if syntax of ip rule command is invalid - returncode = 255
    # if there was an attempt to delete a nonexistent rule - returncode = 254
    
    # example: ip rule add from all iif lo oif eth0 lookup 100
    
    cmd = "ip rule %s from all iif lo oif %s lookup %s" % (action, out_iface, table_id)
    proc = sp.Popen(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE)
    (stout, sterr) = proc.communicate()
    rc = proc.returncode
    
    if rc != 0 and rc != 254:
        print "ERROR: try run: %s, returncode = %s, stdout: %s, sterr: %s" % (cmd, rc, stout, sterr)
        return 1
    
    return 0
    
def ip_route_mgr (action, route, nexthop, table_id):
    # if action == "add" - this function add ip route via 
    # nexthop to specific route table (table_id)
    # if if action == "del" - this function delete ip route
    
    # if syntax of ip route command is invalid - returncode = 255
    # if there was an attempt to delete a nonexistent ip route - returncode = 2
    # if there was an attempt to add a existent ip route - returncode = 2
    
    # example: ip route add default via 172.16.15.1 table 100
    
    if action == "del" and nexthop == None:
        cmd = "ip route %s %s table %s" % (action, route, table_id)
    else:
        cmd = "ip route %s %s via %s table %s" % (action, route, nexthop, table_id)
    
    proc = sp.Popen(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE)
    (stout, sterr) = proc.communicate()
    rc = proc.returncode

    if rc != 0 and rc != 2:
        print "ERROR: try run: %s, returncode = %s, stdout: %s, sterr: %s" % (cmd, rc, stout, sterr)
        return 1
    
    return 0 

def ip_routes_mgr (action, routes, iface, table_id):
    # if action == "add" - this function add ip route via
    # nexthop to specific route table (table_id)
    # if if action == "del" - this function delete ip route
    
    # if syntax of ip route command is invalid - returncode = 255
    # if there was an attempt to delete a nonexistent ip route - returncode = 2
    # if there was an attempt to add a existent ip route - returncode = 2
    
    # example: ip route add default via 172.16.15.1 table 100
    
    link = get_link_by_iface(iface)
    nexthop = link.get('nexthop')
    
    if type(routes) == str:
        routes = [routes] # if variable is string (one route for add/del) - create list from string for iterate over it

    for route in routes:
        cmd = "ip route %s %s via %s table %s" % (action, route, nexthop, table_id)
        proc = sp.Popen(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE)
        (stout, sterr) = proc.communicate()
        rc = proc.returncode

        if rc != 0 and rc != 2:
            print "ERROR: try run: %s, returncode = %s, stdout: %s, sterr: %s" % (cmd, rc, stout, sterr)
            return 1

    return 0    
    
def do_ping (iface, host):
    
    cmd = "ping -c 1 -I %s -W 1 %s" % (iface, host)
    
    proc = sp.Popen(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE)
    (stout, sterr) = proc.communicate()
    rc = proc.returncode
    
    if rc != 0 and rc != 1:
        if sterr != "connect: Network is unreachable\n":
            print "ERROR: try run: %s, returncode = %s, stdout: %s, sterr: %s" % (cmd, rc, stout, sterr)
    
    return rc

def check_and_fix_routes_inconsistency (routes):
    
    for route in routes:
        if route == 'default':
            route = '8.8.8.8/32' # bacause command 'ip route get default' cannot work
        
        cmd = "ip route get %s" % (route)
    
        proc = sp.Popen(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE)
        (stout, sterr) = proc.communicate()
        rc = proc.returncode
        
        if rc != 0:
            print "ERROR: try run: %s, returncode = %s, stdout: %s, sterr: %s" % (cmd, rc, stout, sterr)
            
    return rc    
    
def check_link_status (**link):
    global links_status # dict to store status of links
    status_of_link = None # initial status of link
    count_fails = 0
    count_success = 0
    
    while not shutdown_event.is_set():
        count_dead_hosts = 0
        
        ip_rule_mgr('add', link.get('iface'), link.get('prio'))
        
        ip_route_mgr('add', 'default', link.get('nexthop'), link.get('prio'))
        
        if count_success == num_attempts_to_switch_link_in_active_state:
            print 'Link %s is active' % link.get('iface')
            status_of_link = 'active'
            count_success = 0
            with lock_for_links_status:
                links_status.update({ link.get('iface'): { 'status': status_of_link, 'prio': link.get('prio') } })
                print links_status
        
        if count_fails == num_attempts_to_switch_link_in_fail_state:
            print 'Link %s is fail' % link.get('iface')
            status_of_link = 'fail'
            count_fails = 0
            with lock_for_links_status:
                links_status.update({ link.get('iface'): { 'status': status_of_link, 'prio': link.get('prio') } })
                print links_status                
            
        for host in link.get('track-host'):
            rc = do_ping(link.get('iface'), host)
            if rc != 0:
                count_dead_hosts += 1
        
        if count_dead_hosts == len(link.get('track-host')):
            if status_of_link == 'active' or status_of_link == None:
                count_fails += 1
                count_success = 0
        
        if count_dead_hosts < len(link.get('track-host')):
            if status_of_link == 'fail' or status_of_link == None:
                count_success += 1
                count_fails = 0

        ip_route_mgr('del', 'default', link.get('nexthop'), link.get('prio'))

        ip_rule_mgr('del', link.get('iface'), link.get('prio'))
        
        time.sleep(icmp_interval)
    
    print threading.current_thread().getName(), 'Exiting'

# spawn thread pool
for link in links:
    t = threading.Thread(target=check_link_status, kwargs=link)
    t.start()
    threads.append(t)


def signal_handler (signal, frame):
    # TODO: this function will execute as many as signals it was received
    
    print 'Signal %s was recived' % (signal)
    shutdown_event.set()
    for thread in threads:
        thread.join()
    
    if current_iface is not None:
        print 'Deleting routes via %s interface' % (current_iface)
        ip_routes_mgr('del', routes, current_iface, 'main')
    
    print 'Exit'
    sys.exit(0)
    
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

while True:
    priorities_of_ifaces_in_active_status = []
    count_ifaces_in_fail_status = 0
    
    with lock_for_links_status:
        
        for iface in links_status.keys():
            if links_status[iface]['status'] == 'fail':
                count_ifaces_in_fail_status += 1
                continue            
            if links_status[iface]['status'] == 'active':
                priorities_of_ifaces_in_active_status.append(get_prio_of_iface(iface))
        
        if count_ifaces_in_fail_status == len(links) and all_ifaces_are_in_fail_status is not True:
            print 'All interface are fail'
            all_ifaces_are_in_fail_status = True
            if current_iface is not None:
                print 'Deleting routes via %s interface' % (current_iface)
                ip_routes_mgr('del', routes, current_iface, 'main')
            
            current_iface = None
                
        for iface in links_status.keys():
            if links_status[iface]['status'] == 'active':
                all_ifaces_are_in_fail_status = False
                if get_prio_of_iface(iface) == max(priorities_of_ifaces_in_active_status): # find active iface with max priority
                    active_iface_with_max_prio = iface
                    if current_iface != active_iface_with_max_prio:
                        previous_iface = current_iface
                        
                        if previous_iface is not None:
                            print 'Deleting routes via %s interface' % (previous_iface)
                            ip_routes_mgr('del', routes, current_iface, 'main')
                        
                        print 'Setting routes via %s interface' % (active_iface_with_max_prio)
                        ip_routes_mgr('add', routes, active_iface_with_max_prio, 'main')
                        current_iface = active_iface_with_max_prio
                    
                    if current_iface is not None:
                        ip_routes_mgr('add', routes, current_iface, 'main')
                    
    time.sleep(1)

